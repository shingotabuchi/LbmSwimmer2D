#pragma kernel Init
#pragma kernel WallInit
#pragma kernel BulkNodeInit
#pragma kernel PlotPhase
#pragma kernel PlotSpeed
#pragma kernel PlotDensity
#pragma kernel BouncebackBoundary
#pragma kernel Collision
#pragma kernel InitPhase
#pragma kernel Streaming
int DIM;
float tauLiq,tauGas;
float omegaPhi;
float minSpeed,maxSpeed;
RWTexture2D<float4> renderTexture;
RWStructuredBuffer<float> uv,f,g,phaseRho;
float minRho,maxRho;
float minPhase,maxPhase;
float wallGradient;
float aconst;
float kconst;
float gammaconst;
static float weights[]={4.0/9.0,1.0/9.0,1.0/9.0,1.0/9.0,1.0/9.0,1.0/36.0,1.0/36.0,1.0/36.0,1.0/36.0};
static int cx[9] = {0,1,0,-1,0,1,-1,-1,1};
static int cy[9] = {0,0,1,0,-1,1,1,-1,-1};
static float gradstencilx[9]={0.0,4.0/12.0,0.0,-4.0/12.0,0.0,
                    1.0/12.0,-1.0/12.0,-1.0/12.0,1.0/12.0};
static float gradstencily[9]={0.0,0.0,4.0/12.0,0.0,-4.0/12.0,
                    1.0/12.0,1.0/12.0,-1.0/12.0,-1.0/12.0};
static float laplacestencil[9]={-20.0/6.0,4.0/6.0,4.0/6.0,4.0/6.0,4.0/6.0,
                    1.0/6.0,1.0/6.0,1.0/6.0,1.0/6.0};
static float wxx[] = {0.0, 1.0/3.0, -1.0/6.0, 1.0/3.0, -1.0/6.0, -1.0/24.0, -1.0/24.0, -1.0/24.0, -1.0/24.0};
static float wyy[] = {0.0, -1.0/6.0, 1.0/3.0, -1.0/6.0, 1.0/3.0, -1.0/24.0, -1.0/24.0, -1.0/24.0, -1.0/24.0};
static float wxy[] = {0.0, 0.0, 0.0, 0.0, 0.0, 1.0/4.0, -1.0/4.0, 1.0/4.0, -1.0/4.0};
static float4 colorsOfMap[7] = 
{
    float4(0,0,0,1),
    float4(0,0,1,1),
    float4(0,1,1,1),
    float4(0,1,0,1),
    float4(1,1,0,1),
    float4(1,0,0,1),
    float4(1,1,1,1),
};

int DIMSqrd; 
int DIMSqrd9; 

static float colorPerc = 1.0 / (7.0-1.0);

float4 ColorMap(float val, float maxVal)
{
    if(val > maxVal) val = maxVal;
    float valPerc = val / maxVal;// value%
    int blockIdx = (int)(valPerc / colorPerc);// Idx of 
    float valPercResidual = valPerc - (blockIdx*colorPerc);//remove the part represented of block 
    float percOfColor = valPercResidual / colorPerc;// % of color of this block that will be filled
    float4 cTarget = colorsOfMap[blockIdx];
    float deltaR = 0;
    float deltaG = 0;
    float deltaB = 0;

    if(blockIdx != 6)
    {
        float4 cNext = colorsOfMap[blockIdx + 1];
        deltaR =cNext.x - cTarget.x;
        deltaG =cNext.y - cTarget.y;
        deltaB =cNext.z - cTarget.z;
    }

    float R = cTarget.r + (deltaR * percOfColor);
    float G = cTarget.g + (deltaG * percOfColor);
    float B = cTarget.b + (deltaB * percOfColor);

    return float4(R,G,B,1.0);
}

[numthreads(8, 8, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    int i = (int)id.x;
    int j = (int)id.y;
    if((abs(i - DIM/2.0) <= 10) && (j < 20) && (j >= 1))
    // if((abs(i - DIM/2.0) <= 20) && (abs(j - DIM/2.0) <= 20))
    {
        phaseRho[i + j*DIM] = 1.0;
    }
    else
    {
        phaseRho[i + j*DIM] = -1.0;
    }
}

[numthreads(64, 1, 1)]
void WallInit(uint3 id : SV_DispatchThreadID)
{
    int i = (int)id.x;
    phaseRho[i + 0*DIM] = phaseRho[i + 1*DIM] - wallGradient;
    phaseRho[i + (DIM-1)*DIM] = phaseRho[i + (DIM-2)*DIM] - wallGradient;
}

[numthreads(8, 8, 1)]
void BulkNodeInit(uint3 id : SV_DispatchThreadID)
{
    
    int i = (int)id.x;
    int j = (int)id.y;
    int k,i1,j1;
    float laplace_temp=0.0;
    float gradx_temp=0.0;
    float grady_temp=0.0;
    for(k = 0; k < 9; k++)
    {
        int i1=((uint)(i+cx[k]+DIM)) % (uint)DIM;
        int j1=((uint)(j+cy[k]+DIM)) % (uint)DIM;
        laplace_temp+=laplacestencil[k]*phaseRho[i1 + j1*DIM];
        gradx_temp+=gradstencilx[k]*phaseRho[i1 + j1*DIM];
        grady_temp+=gradstencily[k]*phaseRho[i1 + j1*DIM];
    }

    phaseRho[DIMSqrd + i + j*DIM] = 1.0;
    uv[(i + j * DIM)*2 + 0] = 0.0; 
    uv[(i + j * DIM)*2 + 1] = 0.0;

    float phase_temp=phaseRho[i + j*DIM];
    float dense_temp=phaseRho[DIMSqrd + i + j*DIM];
    float ux_temp=uv[(i + j * DIM)*2 + 0];
    float uy_temp=uv[(i + j * DIM)*2 + 1];
    float feq;
    float geq;
    float sum=0.0;
    float sum_phase=0.0;
    float phase_square=phase_temp*phase_temp;
    float pressure_bulk=dense_temp/3.0+aconst*(-0.5*phase_square+3.0/4.0*phase_square*phase_square)-kconst*phase_temp*laplace_temp;
    float chemical_pot=gammaconst*(aconst*(-phase_temp+phase_temp*phase_temp*phase_temp)-kconst*laplace_temp);

    for (k=1; k<9; k++)
    {
        feq=weights[k]*(3.0*pressure_bulk+3.0*dense_temp*(cx[k]*ux_temp+cy[k]*uy_temp)
                        +4.5*dense_temp*((cx[k]*cx[k]-1.0/3.0)*ux_temp*ux_temp+(cy[k]*cy[k]-1.0/3.0)*uy_temp*uy_temp+2.0*ux_temp*uy_temp*cx[k]*cy[k]))
            +kconst*(wxx[k]*gradx_temp*gradx_temp+wyy[k]*grady_temp*grady_temp+wxy[k]*gradx_temp*grady_temp);
        geq=weights[k]*(3.0*chemical_pot+3.0*phase_temp*(cx[k]*ux_temp+cy[k]*uy_temp)
                        +4.5*phase_temp*((cx[k]*cx[k]-1.0/3.0)*ux_temp*ux_temp+(cy[k]*cy[k]-1.0/3.0)*uy_temp*uy_temp
                                            +2.0*ux_temp*uy_temp*cx[k]*cy[k]));
        sum+=feq;
        sum_phase+=geq;

        f[k + (i + j*DIM)*9]=feq;
        g[k + (i + j*DIM)*9]=geq;
        // f[DIMSqrd9 + k + (i + j*DIM)*9]=feq;
        // g[DIMSqrd9 + k + (i + j*DIM)*9]=geq;
    }
    f[0 + (i + j*DIM)*9]=dense_temp-sum;
    g[0 + (i + j*DIM)*9]=phase_temp-sum_phase;
    // f[DIMSqrd9 + 0 + (i + j*DIM)*9]=dense_temp-sum;
    // g[DIMSqrd9 + 0 + (i + j*DIM)*9]=phase_temp-sum_phase;
}

[numthreads(8, 8, 1)]
void InitPhase(uint3 id : SV_DispatchThreadID)
{
    int i = (int)id.x;
    int j = (int)id.y;
    int k;
    phaseRho[i + j*DIM] = 0.0;
    for(k = 0; k < 9; k++)
    {
        phaseRho[i + j*DIM] += g[k + (i + j*DIM)*9];
    }
}

[numthreads(8, 8, 1)]
void PlotPhase(uint3 id : SV_DispatchThreadID)
{
    int i = (int)id.x;
    int j = (int)id.y;
    float phase = phaseRho[i + j*DIM];
    renderTexture[id.xy] = ColorMap(phase-minPhase,maxPhase-minPhase);
}
[numthreads(8, 8, 1)]
void PlotSpeed(uint3 id : SV_DispatchThreadID)
{
    int i = (int)id.x;
    int j = (int)id.y;
    float speed = sqrt(uv[(i + j * DIM)*2 + 0] * uv[(i + j * DIM)*2 + 0] + uv[(i + j * DIM)*2 + 1] * uv[(i + j * DIM)*2 + 1]);
    renderTexture[id.xy] = ColorMap(speed-minSpeed,maxSpeed-minSpeed);
}
[numthreads(8, 8, 1)]
void PlotDensity(uint3 id : SV_DispatchThreadID)
{
    int i = (int)id.x;
    int j = (int)id.y;
    float density = phaseRho[DIM*DIM + i + j*DIM];
    renderTexture[id.xy] = ColorMap(density-minRho,maxRho-minRho);
}

[numthreads(64, 1, 1)]
void BouncebackBoundary(uint3 id : SV_DispatchThreadID)
{
    int i = (int)id.x;
    int iXtop=(int)(((uint)(i+1+DIM))%(uint)DIM);
    int iXbottom=(int)(((uint)(i-1+DIM))%(uint)DIM);

    f[DIMSqrd9 + 2 + (i + 0*DIM)*9]=f[DIMSqrd9 + 4 + (i + 1*DIM)*9];
    f[DIMSqrd9 + 5 + (i + 0*DIM)*9]=f[DIMSqrd9 + 7 + (iXtop + 1*DIM)*9];
    f[DIMSqrd9 + 6 + (i + 0*DIM)*9]=f[DIMSqrd9 + 8 + (iXbottom + 1*DIM)*9];

    f[DIMSqrd9 + 4 + (i + (DIM-1)*DIM)*9]=f[DIMSqrd9 + 2 + (i + (DIM-2)*DIM)*9];
    f[DIMSqrd9 + 7 + (i + (DIM-1)*DIM)*9]=f[DIMSqrd9 + 5 + (iXbottom + (DIM-2)*DIM)*9];
    f[DIMSqrd9 + 8 + (i + (DIM-1)*DIM)*9]=f[DIMSqrd9 + 6 + (iXtop + (DIM-2)*DIM)*9];


    g[DIMSqrd9 + 2 + (i + 0*DIM)*9]=g[DIMSqrd9 + 4 + (i + 1*DIM)*9];
    g[DIMSqrd9 + 5 + (i + 0*DIM)*9]=g[DIMSqrd9 + 7 + (iXtop + 1*DIM)*9];
    g[DIMSqrd9 + 6 + (i + 0*DIM)*9]=g[DIMSqrd9 + 8 + (iXbottom + 1*DIM)*9];

    g[DIMSqrd9 + 4 + (i + (DIM-1)*DIM)*9]=g[DIMSqrd9 + 2 + (i + (DIM-2)*DIM)*9];
    g[DIMSqrd9 + 7 + (i + (DIM-1)*DIM)*9]=g[DIMSqrd9 + 5 + (iXbottom + (DIM-2)*DIM)*9];
    g[DIMSqrd9 + 8 + (i + (DIM-1)*DIM)*9]=g[DIMSqrd9 + 6 + (iXtop + (DIM-2)*DIM)*9];

    phaseRho[DIMSqrd + i + 0*DIM] = 1.0;
    phaseRho[DIMSqrd + i + (DIM-1)*DIM] = 1.0;
    uv[(i + 0 * DIM)*2 + 0] = 0.0; 
    uv[(i + 0 * DIM)*2 + 1] = 0.0;
    uv[(i + (DIM-1) * DIM)*2 + 0] = 0.0; 
    uv[(i + (DIM-1) * DIM)*2 + 1] = 0.0;
}

[numthreads(8, 8, 1)]
void Collision(uint3 id : SV_DispatchThreadID)
{
    
    int i = (int)id.x;
    int j = (int)id.y;
    int k,i1,j1;
    //Construction equilibrium
    phaseRho[DIMSqrd + i + j*DIM]=0.0;
    uv[(i + j * DIM)*2 + 0]=0.0;
    uv[(i + j * DIM)*2 + 1]=0.0;

    for(k=0;k<9;k++)
    {
        phaseRho[DIMSqrd + i + j*DIM]+=f[k + (i + j*DIM)*9];
        uv[(i + j * DIM)*2 + 0]+=f[k + (i + j*DIM)*9]*cx[k];
        uv[(i + j * DIM)*2 + 1]+=f[k + (i + j*DIM)*9]*cy[k];
    }

    uv[(i + j * DIM)*2 + 0]=uv[(i + j * DIM)*2 + 0]/phaseRho[DIMSqrd + i + j*DIM];
    uv[(i + j * DIM)*2 + 1]=uv[(i + j * DIM)*2 + 1]/phaseRho[DIMSqrd + i + j*DIM];


    float laplace_temp=0.0;
    float gradx_temp=0.0;
    float grady_temp=0.0;
    for(k=0;k<9;k++)
    {
        int i1=(int)(((uint)(i+cx[k]+DIM)) % (uint)DIM);
        int j1=(int)(((uint)(j+cy[k]+DIM)) % (uint)DIM);
        laplace_temp+=laplacestencil[k]*phaseRho[i1 + j1*DIM];
        gradx_temp+=gradstencilx[k]*phaseRho[i1 + j1*DIM];
        grady_temp+=gradstencily[k]*phaseRho[i1 + j1*DIM];
    }

    float phase_temp=phaseRho[i + j*DIM];
    float dense_temp=phaseRho[DIMSqrd + i + j*DIM];
    float ux_temp=uv[(i + j * DIM)*2 + 0];
    float uy_temp=uv[(i + j * DIM)*2 + 1];
    float sum=0.0;
    float sum_phase=0.0;
    float phase_square=phase_temp*phase_temp;
    float pressure_bulk=dense_temp/3.0+aconst*(-0.5*phase_square+3.0/4.0*phase_square*phase_square)-kconst*phase_temp*laplace_temp;
    float chemical_pot=gammaconst*(aconst*(-phase_temp+phase_temp*phase_temp*phase_temp)-kconst*laplace_temp);
    float feqeq,geqeq;
    float tau_rho=tauGas+(phase_temp+1.0)/2.0*(tauLiq-tauGas);
    float omega_rho=1.0/tau_rho;
    for (k=1; k<9; k++)
    {
        feqeq=weights[k]*(3.0*pressure_bulk+3.0*dense_temp*(cx[k]*ux_temp+cy[k]*uy_temp)
                        +4.5*dense_temp*((cx[k]*cx[k]-1.0/3.0)*ux_temp*ux_temp+(cy[k]*cy[k]-1.0/3.0)*uy_temp*uy_temp+2.0*ux_temp*uy_temp*cx[k]*cy[k]))
        +kconst*(wxx[k]*gradx_temp*gradx_temp+wyy[k]*grady_temp*grady_temp+wxy[k]*gradx_temp*grady_temp);
        geqeq=weights[k]*(3.0*chemical_pot+3.0*phase_temp*(cx[k]*ux_temp+cy[k]*uy_temp)
                        +4.5*phase_temp*((cx[k]*cx[k]-1.0/3.0)*ux_temp*ux_temp+(cy[k]*cy[k]-1.0/3.0)*uy_temp*uy_temp+2.0*ux_temp*uy_temp*cx[k]*cy[k]));
        sum+=feqeq;
        sum_phase+=geqeq;
        f[DIMSqrd9 + k + (i + j*DIM)*9]=f[k + (i + j*DIM)*9]*(1.0-omega_rho)+omega_rho*feqeq;
        g[DIMSqrd9 + k + (i + j*DIM)*9]=g[k + (i + j*DIM)*9]*(1.0-omegaPhi)+omegaPhi*geqeq;
    }

    feqeq=dense_temp-sum;
    geqeq=phase_temp-sum_phase;

    f[DIMSqrd9 + 0 + (i + j*DIM)*9]=f[0 + (i + j*DIM)*9]*(1.0-omega_rho)+omega_rho*feqeq;
    g[DIMSqrd9 + 0 + (i + j*DIM)*9]=g[0 + (i + j*DIM)*9]*(1.0-omegaPhi)+omegaPhi*geqeq;
}

[numthreads(8, 8, 1)]
void Streaming(uint3 id : SV_DispatchThreadID)
{
    int i = (int)id.x;
    int j = (int)id.y;
    int k,i1,j1;
    for(k=0;k<9;k++)
    {
        int i1=(int)(((uint)(i-cx[k]+DIM)) % (uint)DIM);
        int j1=(int)(((uint)(j-cy[k]+DIM)) % (uint)DIM);
        f[k + (i + j*DIM)*9] = f[DIMSqrd9 + k + (i1 + j1*DIM)*9];
        g[k + (i + j*DIM)*9] = g[DIMSqrd9 + k + (i1 + j1*DIM)*9];
    }
}



