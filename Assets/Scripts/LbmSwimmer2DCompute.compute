#pragma kernel ImmersedBoundary

struct RoundParticleSmallData
{
	float density;
    float omega;//角速度
    float theta;//角
    float prevOmega1;//前フレームの角速度
    float prevOmega2;//前々フレームの角速度
    float torque;
    int perimeterPointCount;
    float volume;
    float mass;
    float momentOfInertia;
    float radius;
    int bottomPointIndex;

    float2 pos;
    float2 vel;
    float2 prevVel1;
    float2 prevVel2;
    float2 forceFromCollisions;
    float2 forceFromFluid;
};
struct RoundParticlePerimeterPos
{
    float perimeterPos[300*2];
};
struct RoundParticlePerimeterVel
{
    float perimeterVel[300*2];
};
struct RoundParticlePerimeterFluidVel
{
    float perimeterFluidVel[300*2];
};
struct RoundParticleForceOnPerimeter
{
    float forceOnPerimeter[300*2];
};

RWStructuredBuffer<RoundParticleSmallData> roundParticleSmallDataBuffer;
RWStructuredBuffer<RoundParticlePerimeterPos> roundParticleRoundParticlePerimeterPosBuffer;
RWStructuredBuffer<RoundParticlePerimeterVel> roundParticleRoundParticlePerimeterVelBuffer;
RWStructuredBuffer<RoundParticlePerimeterFluidVel> roundParticleRoundParticlePerimeterFluidVelBuffer;
RWStructuredBuffer<RoundParticleForceOnPerimeter> roundParticleRoundParticleForceOnPerimeterBuffer;

const float pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164;
float zeta,epsw;
int DIM_X,DIM_Y;

[numthreads(128,1,1)]
void ImmersedBoundary (uint3 id : SV_DispatchThreadID)
{
    float tmp1,tmp2,tmp3;
    roundParticleSmallDataBuffer[id.x].forceFromCollisions[0] = 0;
    roundParticleSmallDataBuffer[id.x].forceFromCollisions[1] = 0;
    tmp1 = abs(roundParticleSmallDataBuffer[id.x].pos[1] + roundParticleSmallDataBuffer[id.x].radius); 
    if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
        roundParticleSmallDataBuffer[id.x].forceFromCollisions[1] = (roundParticleSmallDataBuffer[id.x].pos[1] + roundParticleSmallDataBuffer[id.x].radius)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
    }
    tmp1 = abs(DIM_Y-1-roundParticleSmallDataBuffer[id.x].pos[1] + roundParticleSmallDataBuffer[id.x].radius); 
    if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
        roundParticleSmallDataBuffer[id.x].forceFromCollisions[1] = -(DIM_Y-1-roundParticleSmallDataBuffer[id.x].pos[1] + roundParticleSmallDataBuffer[id.x].radius)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
    }
    tmp1 = abs(roundParticleSmallDataBuffer[id.x].pos[0] + roundParticleSmallDataBuffer[id.x].radius); 
    if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
        roundParticleSmallDataBuffer[id.x].forceFromCollisions[0] = (roundParticleSmallDataBuffer[id.x].pos[0] + roundParticleSmallDataBuffer[id.x].radius)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
    }
    tmp1 = abs(DIM_X-1-roundParticleSmallDataBuffer[id.x].pos[0] + roundParticleSmallDataBuffer[id.x].radius); 
    if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
        roundParticleSmallDataBuffer[id.x].forceFromCollisions[0] = -(DIM_X-1-roundParticleSmallDataBuffer[id.x].pos[0] + roundParticleSmallDataBuffer[id.x].radius)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
    }

    // for (int k = 0; k < particleCount; k++)
    // {
    //     if(k==n) continue;
    //     for (int i = 0; i < 2; i++)
    //     {
    //         tmp1 = roundParticles[n].ParticleDistance(roundParticles[k]);
    //         if(tmp1 < 2.0*roundParticleSmallDataBuffer[id.x].radius + zeta){
    //             roundParticleSmallDataBuffer[id.x].forceFromCollisions[i] += (roundParticleSmallDataBuffer[id.x].pos[i] - roundParticles[k].smallData.pos[i])*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)*(2.0*roundParticleSmallDataBuffer[id.x].radius - tmp1 + zeta)/epsw;
    //         }
    //     }
    // }

    roundParticleSmallDataBuffer[id.x].forceFromFluid[0] = 0;
    roundParticleSmallDataBuffer[id.x].forceFromFluid[1] = 0;
    roundParticleSmallDataBuffer[id.x].torque = 0;
    for(int m = 0; m < roundParticleSmallDataBuffer[id.x].perimeterPointCount ; m++) 
    {
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x].perimeterFluidVel[m*2 + 0] = 0;
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x].perimeterFluidVel[m*2 + 1] = 0;
        // 固体表面の速度を計算
        for(int i = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 0] - 3; i < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 0] + 3; i++)
        {
            for(int j = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 1] - 3; j < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 1] + 3; j++)
            {
                tmp1 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 0] - (float)i);
                tmp2 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 1] - (float)j);
                if(tmp1 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp1/2.0))/4.0;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                if(tmp2 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp2/2.0))/4.0*tmp3;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                if((j<DIM_Y&&j>=0) && (i<DIM_X&&i>=0))
                {
                    roundParticleRoundParticlePerimeterFluidVelBuffer[id.x].perimeterFluidVel[m*2 + 0] += u[i,j]*tmp3;
                    roundParticleRoundParticlePerimeterFluidVelBuffer[id.x].perimeterFluidVel[m*2 + 1] += v[i,j]*tmp3;
                }
            } 
        }
        float boundaryPointTheta = roundParticleSmallDataBuffer[id.x].theta + m * 2f * pi / roundParticleSmallDataBuffer[id.x].perimeterPointCount;
        float sin = sin(boundaryPointTheta);
        float cos = cos(boundaryPointTheta);
        float surfaceVelocityNorm = squirmerSpeedConstant * ( sin + 2f * squirmerBeta * sin * cos );
        Vector2 surfaceVelocity = new Vector2(cos,-sin) * surfaceVelocityNorm;
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x].perimeterFluidVel[m*2 + 0] += surfaceVelocity[0];
        roundParticleRoundParticlePerimeterFluidVelBuffer[id.x].perimeterFluidVel[m*2 + 1] += surfaceVelocity[1];
        roundParticleRoundParticleForceOnPerimeterBuffer[id.x].forceOnPerimeter[m*2 + 0] = roundParticleRoundParticlePerimeterVelBuffer[id.x].perimeterVel[m*2 + 0] - roundParticleRoundParticlePerimeterFluidVelBuffer[id.x].perimeterFluidVel[m*2 + 0];
        roundParticleRoundParticleForceOnPerimeterBuffer[id.x].forceOnPerimeter[m*2 + 1] = roundParticleRoundParticlePerimeterVelBuffer[id.x].perimeterVel[m*2 + 1] - roundParticleRoundParticlePerimeterFluidVelBuffer[id.x].perimeterFluidVel[m*2 + 1];

        // 固体が外部に与える力を計算
        for(int i = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 0] - 3; i < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 0] + 3; i++)
        {
            for(int j = (int)roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 1] - 3; j < (int)roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 1] + 3; j++)
            {
                tmp1 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 0] - (float)i);
                tmp2 = abs(roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 1] - (float)j);
                if(tmp1 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp1/2.0))/4.0;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                if(tmp2 <= 2.0)
                {
                    tmp3 = (1.0 + cos(pi*tmp2/2.0))/4.0*tmp3;
                } 
                else 
                {
                    tmp3 = 0.0;
                }
                if((j<DIM_Y&&j>=0) && (i<DIM_X&&i>=0))
                {
                    fx[i,j] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x].forceOnPerimeter[m*2 + 0] * tmp3 * 2.0*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;
                    fy[i,j] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x].forceOnPerimeter[m*2 + 1] * tmp3 * 2.0*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;
                }
            } 
        }
        roundParticleSmallDataBuffer[id.x].forceFromFluid[0] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x].forceOnPerimeter[m*2 + 0];
        roundParticleSmallDataBuffer[id.x].forceFromFluid[1] += roundParticleRoundParticleForceOnPerimeterBuffer[id.x].forceOnPerimeter[m*2 + 1];
        roundParticleSmallDataBuffer[id.x].torque += roundParticleRoundParticleForceOnPerimeterBuffer[id.x].forceOnPerimeter[m*2 + 1] * (roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 0] - roundParticleSmallDataBuffer[id.x].pos[0]) 
                                - roundParticleRoundParticleForceOnPerimeterBuffer[id.x].forceOnPerimeter[m*2 + 0] * (roundParticleRoundParticlePerimeterPosBuffer[id.x].perimeterPos[m*2 + 1] - roundParticleSmallDataBuffer[id.x].pos[1]);
    } 

    roundParticleSmallDataBuffer[id.x].forceFromFluid[0] *= -2f*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;  
    roundParticleSmallDataBuffer[id.x].forceFromFluid[1] *= -2f*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;  
    roundParticleSmallDataBuffer[id.x].torque *= -2f*pi*roundParticleSmallDataBuffer[id.x].radius/(float)roundParticleSmallDataBuffer[id.x].perimeterPointCount;  
}